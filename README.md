This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [:5173](http://localhost:5173/) with your browser to see the result.

sequenceDiagram
    participant User
    participant Client as Client/UI
    participant Middleware as API Middleware
    participant Route as Auth Route
    participant BetterAuth as Better Auth
    participant DB as Database
    participant Resend as Resend Email

    rect rgb(200, 220, 255)
    note over User,Resend: Sign-Up with Email Verification (New Flow)
    User->>Client: Enter email & password
    Client->>Route: POST /api/auth/signup
    Middleware->>Middleware: Check rate limit & bot
    Middleware->>Route: Allow request
    Route->>BetterAuth: Sign up with email/password
    BetterAuth->>DB: Create user, generate token
    BetterAuth->>Resend: Send verification email
    Resend->>User: Verification link email
    Client->>Client: Show "Check your email"
    end

    rect rgb(220, 240, 220)
    note over User,Resend: Passkey Registration (New Flow)
    User->>Client: Click "Register Passkey"
    Client->>Route: GET /api/passkey/check-returning-user
    Middleware->>Middleware: Check IP rate limit
    Route->>DB: Query session & user
    Route->>Client: Return { hasPasskey, user }
    Client->>BetterAuth: Add passkey
    BetterAuth->>DB: Store passkey credentials
    Client->>Client: Redirect to home
    end

    rect rgb(255, 240, 200)
    note over User,Middleware: Rate Limit & Bot Detection (New Middleware)
    User->>Client: Make API request
    Middleware->>Middleware: Extract user-agent
    Middleware->>Middleware: Check against bot patterns
    alt Bot detected
        Middleware->>Client: Return 403 Forbidden
    else Rate limit exceeded
        Middleware->>Client: Return 429 Too Many Requests
    else Allowed
        Middleware->>Route: Add headers, forward
        Route->>Client: Response + x-ratelimit-remaining
    end
    end


You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

### Better Auth workflow

what better-auth does

1. Signup (email/password)

    Frontend calls better-auth signup API (or the route provided by better-auth).
    better-auth calls Cognito SignUp API for the configured User Pool.
    If emailVerification.sendVerificationEmail is configured (it is), better-auth will call that callback with a verification URL that your app sends via SES (you implemented that).
    Cognito's email verification flag should be enabled (or better-auth will require it). The user remains unconfirmed until they click the link.

2. Email verification

    User clicks verification link (the URL you generated by better-auth).
    The verification route exchanges code/params with Cognito (or uses admin confirm if configured) and marks the user confirmed.
    If autoSignInAfterVerification: true, better-auth will sign them in automatically (returns session tokens).

3. Sign-in / Session management

    Signing in triggers Cognito authentication (SRP or OAuth) and Cognito issues id/access/refresh tokens.
    better-auth manages session cookies/tokens per the session config: it will use its configured lifetimes and should handle refresh token exchange with Cognito when access tokens expire (depending on the integration implementation).
    Your Drizzle adapter can store session metadata or user mappings as needed (refresh token rotation metadata, API keys, etc.).

4. Token refresh & expiry

    accessTokenExpiresIn, refreshTokenExpiresIn, idleTimeout, etc., are taken from your SESSION_TIMEOUT constants and applied by better-auth.
    Ensure Cognito's App Client is configured to issue refresh tokens for the same TTL you expect. Mismatch could lead to refresh attempts failing.

5. Social login (GitHub, Google)

    better-auth will initiate the OAuth redirect to Cognito's Hosted UI or to the provider via Cognito (depends on better-auth implementation).
    Cognito must be configured with the social provider client IDs/secrets and callback URLs.

6. Magic-link

    better-auth provides a magic-link flow; when enabled it may either:
    Use Cognito custom auth/CustomChallenge flows to implement magic links behind the scenes, or
    Implement magic links in the better-auth layer (issuing one-time tokens stored in your DB and validating upon click).
    Verify better-auth's Cognito adapter docs to confirm whether magic link relies on Cognito custom auth flows or on better-auth-native behavior.

7. Two-factor (2FA)

    The twoFactor() plugin enables 2FA support in better-auth.
    Implementation details: it may integrate with TOTP secrets stored by better-auth (in DB) and use Cognito only for primary account. If you want Cognito-managed MFA, ensure the adapter supports mapping better-auth 2FA workflows with Cognito's MFA settings (or use better-auth's own TOTP flows).
